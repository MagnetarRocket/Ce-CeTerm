/*static char *sccsid = "%Z% %M% %I% - %G% %U% ";*/

/***************************************************************
*  
*  ARPUS/Ce text editor and terminal emulator modeled after the
*  Apollo(r) Domain systems.
*  Copyright 1988 - 2002 Enabling Technologies Group
*  Copyright 2003 - 2005 Robert Styma Consulting
*  
*  This program is free software; you can redistribute it and/or
*  modify it under the terms of the GNU General Public License
*  as published by the Free Software Foundation; either version 2
*  of the License, or (at your option) any later version.
*  
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*  
*  You should have received a copy of the GNU General Public License
*  along with this program; if not, write to the Free Software
*  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*  
*  Original Authors:  Robert Styma and Kevin Plyler
*  Email:  styma@swlink.net
*  
***************************************************************/

/***************************************************************
*
*  module keypress.c
*
*  Routine:
*     keypress    - Process KeyPress, KeyRelease, ButtonPress, ButtonRelease
*
***************************************************************/


#include <stdio.h>          /* /usr/include/stdio.h      */
#include <errno.h>          /* /usr/include/errno.h      */
#include <string.h>         /* /usr/include/string.h   */
#include <limits.h>         /* /usr/include/limits.h   */
#include <sys/types.h>      /* "/usr/include/sys/types.h"     */

#include "cc.h"
#include "cswitch.h"
#include "debug.h"
#include "dmc.h"
#include "dmwin.h"
#include "getevent.h"
#include "kd.h"
#include "keypress.h"
#include "mark.h"
#include "parms.h"
#include "parsedm.h"
#include "prompt.h"
#include "pw.h"
#include "record.h"
#include "redraw.h"
#include "tab.h"
#include "typing.h"
#include "undo.h"
#include "winsetup.h"
#include "xerror.h"
#include "xerrorpos.h"


/************************************************************************

NAME:      exec_dm_list  -  Loop to execute a list of DMC's

PURPOSE:    This routine does executes a list of dmc's

PARAMETERS:

   1.  dspl_descr      - pointer to DISPLAY_DESCR  (INPUT/OUTPUT)
                         This is the current display description.
                            
   2.  dm_list         - pointer to DMC  (INPUT)
                         This is the DM command to execute
                            
   3.  new_dmc         - pointer to pointer to DMC  (OUTPUT)
                         If any DM command structures are generated, the head
                         of the list of these is put in this output variable.
                         It is set if DMC's are generated by the commands
                         which are executed.

   4.  event_union     - pointer to XEvent (INPUT)
                         This is the event which caused the DM commands to get
                         executed.  It the event structure for a:
                         KeyPress, KeyRelease, ButtonPress, ButtonRelease
                         It is passed through to cswitch.c

   5.  read_locked     - int  (INPUT)
                         Read locked flag.  Prevents "ro" commands if True.
                         Passed through to cwitch.c
                            
   6.  warp_needed     - pointer to int (OUTPUT)
                         True if the cursor needs to be warped as a result
                         of the DM command.
                         Passed through to cwitch.c

   7.  wc_display_deleted     - pointer to pointer to DISPLAY_DESCR (OUTPUT)
                         This flag tells the caller the display was actually closed down.
                         It is used in when there are multiple CC windows.
                         If non-NULL, it is the display description of the next display
                         after the one which has just been destroyed.  When this value
                         is non-NULL, do not use parameter dspl_descr any more.
                         non-NULL -  A cc window was closed, value is the next
                                     cc window in the list.
                         NULL      - No windows deleted, maybe a prompt was issued
                         Passed through to cwitch.c

   8.  stop_dm_list     - pointer to int (OUTPUT)
                         True causes the list of DM commands to stop being processed.
                         Normally caused by prompts or finds which failed. Differs
                         from wc_display_deleted, in that normal post DM command calls
                         to update the display should be made.
                         Passed through to cwitch.c

   9.  modifies_main_pad - pointer to int (OUTPUT)
                         Set to True to show that some command in the list modifies the
                         the main pad.  This causes keypress.c to count this keypress
                         when doing counts for autosave.  It is only set in this
                         routine.  It is passed through to cswitch.c to  because
                         DM_IND calls this routine recursively.

   10.  arg0           - pointer to char (INPUT)
                         The command name, passed to lower level routines.
                         Passed through to cwitch.c

FUNCTIONS :

   1.   Make sure all the keydefs are loaded.

   2.   If we are in kk mode, display the kk information and return.

   3.   If there are commands waiting to process, parse them.  Otherwise
        get the command associated with this keypress.

   4.   Do the command list prescanning (see embedded comments)

   5.   Process each command with cswitch.

*************************************************************************/

int  exec_dm_list(DISPLAY_DESCR  *dspl_descr,         /* in/out */
                  DMC            *dm_list,            /* input  */
                  DMC           **new_dmc,            /* output */
                  XEvent         *event_union,        /* input  KeyPress, KeyRelease, ButtonPress, ButtonRelease */
                  int             read_locked,        /* input  */
                  int            *warp_needed,        /* output */
                  DISPLAY_DESCR **wc_display_deleted, /* output */
                  int            *stop_dm_list,       /* output */
                  int            *modifies_main_pad,  /* output */
                  char           *arg0)               /* input  */
{
DMC                  *hold_dmc;         /* work variable in walking the dm_list                          */
DMC                  *temp_dmc;         /*           "       "                                           */
char                  msg[MAX_LINE];


/***************************************************************
*  Variables saved between keystrokes
***************************************************************/


/***************************************************************
*  Walk the list of DM commands.
***************************************************************/
while(dm_list != NULL)
{
   /***************************************************************
   *  If a dm comment was entered to be executed, skip it.
   ***************************************************************/
   if (dm_list == DMC_COMMENT)
      break;

   /***************************************************************
   *  If this command modifies the main window, record this fact.
   ***************************************************************/
   if ((dmsyms[dm_list->any.cmd].modifies_buff) && (dspl_descr->cursor_buff->current_win_buff->which_window == MAIN_PAD))
      *modifies_main_pad = True;

   DEBUG4(dump_kd(stderr, dm_list, 1 /* print just the current key def */, False, NULL, dspl_descr->escape_char);)

   /***************************************************************
   *  If a cursor motion event has put part of the new cursor buff
   *  out of date, bring it up to date.
   ***************************************************************/
   if (!dspl_descr->cursor_buff->up_to_snuff)
      bring_up_to_snuff(dspl_descr);

   /***************************************************************
   *  If we are in vt100 mode and this command is not allowed,
   *  Flag this fact.
   ***************************************************************/
   if (dspl_descr->vt100_mode && !VT100_CMD_VALID(dspl_descr->cursor_buff->which_window, dm_list->any.cmd))
      {
         sprintf(msg, "(%s) Command not allowed in VT100 mode", dmsyms[dm_list->any.cmd].name);
         dm_error(msg, DM_ERROR_MSG);
         break; /* forget rest of key event */
      }

   /***************************************************************
   *  If the command modifies the buffer and we are in a read only
   *  window, bail out with a message.
   ***************************************************************/
   if ((dmsyms[dm_list->any.cmd].modifies_buff) || (dm_list->any.cmd == DM_undo) || (dm_list->any.cmd == DM_redo))
      {
         if (!(WRITABLE(dspl_descr->cursor_buff->current_win_buff->token)))
            {
#ifdef PAD
               if (dspl_descr->pad_mode && (dspl_descr->cursor_buff->current_win_buff->which_window == MAIN_PAD))
                  {
                     dspl_descr->cursor_buff->which_window = UNIXCMD_WINDOW;
                     dspl_descr->cursor_buff->win_line_no  = dspl_descr->unix_pad->file_line_no - dspl_descr->unix_pad->first_line;
                     dspl_descr->cursor_buff->win_col_no   = dspl_descr->unix_pad->file_col_no  - dspl_descr->unix_pad->first_char;
                     bring_up_to_snuff(dspl_descr);
                     set_window_col_from_file_col(dspl_descr->cursor_buff);
                     dspl_descr->cursor_buff->y = dspl_descr->cursor_buff->current_win_buff->window->sub_y + (dspl_descr->cursor_buff->win_line_no * dspl_descr->cursor_buff->current_win_buff->window->line_height);
                  }
               else
                  {
                     dm_error("Text is read-only", DM_ERROR_BEEP);
                     break; /* forget rest of key event */
                  }
#else
               dm_error("Text is read-only", DM_ERROR_BEEP);
               break; /* forget rest of key event */
#endif
            }
         else
            {
               /* RES 12/4/95 test added to deal with x'ed out lines */
               if (dspl_descr->cursor_buff->current_win_buff->win_lines[dspl_descr->cursor_buff->win_line_no].w_file_lines_here > 1)
                  {
                     sprintf(msg, "Line %d excluded, cannot be direct target for update", dspl_descr->cursor_buff->current_win_buff->file_line_no+1);
                     dm_error(msg, DM_ERROR_BEEP);
                     break; /* forget rest of key event */
                  }
               if (cc_ce && (dspl_descr->cursor_buff->which_window == MAIN_PAD) && cc_line_chk(dspl_descr->cursor_buff->current_win_buff->token, dspl_descr, dspl_descr->main_pad->file_line_no))
                  {
                     sprintf(msg, "Line %d already in use in another window", dspl_descr->main_pad->file_line_no+1);
                     dm_error(msg, DM_ERROR_BEEP);
                     break; /* forget rest of key event */
                  }
            }
         if (dspl_descr->cursor_buff->win_line_no < 0)
            {
               /* we are in the titlebar area of a writeable window */
               dm_error("No text under cursor", DM_ERROR_BEEP);
               break; /* forget rest of key event */
            }
         /* if this is the first modification since the last save, force a titlebar redraw */
         if (!dirty_bit(dspl_descr->cursor_buff->current_win_buff->token))
            redraw_needed |= TITLEBAR_MASK & FULL_REDRAW;
      }

   /***************************************************************
   *  If the command we will be executing requires a clean work
   *  buffer, and it is dirty (in use), clear it out.
   *  On compound commands, force a full screen redraw to avoid
   *  side effects.
   ***************************************************************/
   if (dmsyms[dm_list->any.cmd].needs_flush && dspl_descr->cursor_buff->current_win_buff->buff_modified)
      {
         flush(dspl_descr->cursor_buff->current_win_buff);
         if (redraw_needed)
            redraw_needed |= (dspl_descr->cursor_buff->current_win_buff->redraw_mask & PARTIAL_REDRAW);
      }

   /***************************************************************
   *  If we will be modifying a buffer and we are
   *  not in modify mode, we need to set up the local work buffer.
   ***************************************************************/
   if (dmsyms[dm_list->any.cmd].modifies_buff &&
       ((dspl_descr->cursor_buff->current_win_buff->buff_ptr != dspl_descr->cursor_buff->current_win_buff->work_buff_ptr) ||
        ((dspl_descr->cursor_buff->win_line_no + dspl_descr->cursor_buff->current_win_buff->first_line) != dspl_descr->cursor_buff->current_win_buff->file_line_no)))
      {
         if (((dspl_descr->cursor_buff->win_line_no + dspl_descr->cursor_buff->current_win_buff->first_line) != dspl_descr->cursor_buff->current_win_buff->file_line_no) ||
             (dspl_descr->cursor_buff->which_window != dspl_descr->cursor_buff->current_win_buff->which_window))
            bring_up_to_snuff(dspl_descr);
         else
            if (dmsyms[dm_list->any.cmd].needs_flush && dspl_descr->cursor_buff->current_win_buff->buff_modified)
               flush(dspl_descr->cursor_buff->current_win_buff);

         if (check_and_add_lines(dspl_descr->cursor_buff)) /* in mark.c */
            redraw_needed |= (FULL_REDRAW & MAIN_PAD_MASK); /* force partial redraw in case line numbers need to be added */

         strcpy(dspl_descr->cursor_buff->current_win_buff->work_buff_ptr, dspl_descr->cursor_buff->current_win_buff->buff_ptr);
         dspl_descr->cursor_buff->current_win_buff->buff_ptr = dspl_descr->cursor_buff->current_win_buff->work_buff_ptr;
      }


   /***************************************************************
   *  Switch on the command id to decide what to do.
   ***************************************************************/
   redraw_needed |= cswitch(dspl_descr,          /* in/out */
                            dm_list,             /* input  */
                            new_dmc,             /* output */
                            event_union,         /* input */
                            read_locked,         /* input  */
                            warp_needed,         /* output */
                            wc_display_deleted,  /* output */
                            stop_dm_list,        /* output */
                            modifies_main_pad    /* output */
                            arg0);               /* input  */
   if (wc_display_deleted)
      {
         DEBUG1(fprintf(stderr, "process_keypress: cc display deleted, bye bye\n");)
         process_redraw(wc_display_deleted, (FULL_REDRAW & MAIN_PAD_MASK), False);
         return; /* the display is gone.  Do nothing more with it */
      }

   if (stop_dm_list)
      {
         DEBUG1(fprintf(stderr, "process_keypress: cmd list suspended\n");)
         dm_list = NULL;
      }

   /***************************************************************
   *  
   *  If the command failed to modify the work buffer, revert the
   *  buffer to the work buffer.
   *  
   ***************************************************************/

   if ((dspl_descr->cursor_buff->current_win_buff->buff_ptr == dspl_descr->cursor_buff->current_win_buff->work_buff_ptr) &&
       !dspl_descr->cursor_buff->current_win_buff->buff_modified)
      dspl_descr->cursor_buff->current_win_buff->buff_ptr = get_line_by_num(dspl_descr->cursor_buff->current_win_buff->token, dspl_descr->cursor_buff->current_win_buff->file_line_no);

   /***************************************************************
   *  Go to the next command.  Free this one if required.
   *  The dm_list can be null if the list was shunted to the
   *  prompt stack by dm_prompt.
   ***************************************************************/
   if (dm_list != NULL)
      if (dm_list->any.temp)
         {
            hold_dmc = dm_list->next;
            dm_list->next = NULL;  /* only want to free 1 */
            free_dmc(dm_list);
            dm_list = hold_dmc;
         }
      else
         dm_list = dm_list->next;

   /***************************************************************
   *  If there are no new dm commands to put on the list, see if
   *  any prompts have been completed.
   ***************************************************************/
   if (new_dmc == NULL)
      new_dmc = process_prompt(dspl_descr);

   /***************************************************************
   *  If new DM commands were created, put them on the front of the
   *  list if there is anything else on the list.
   *  This counts on the last dmc in the list being a temp.
   ***************************************************************/
   if ((new_dmc != NULL) && (new_dmc != DMC_COMMENT))
      {
         if (dm_list != NULL)
            {
               for (temp_dmc = new_dmc;
                    temp_dmc->next != NULL;
                    temp_dmc = temp_dmc->next)
                  ; /* do nothing */
               temp_dmc->next = dm_list;
            }
         dm_list = new_dmc;
         new_dmc = NULL;
      }
} /* end of while walking dm_list */

return(redraw_needed);

} /* end of exec_dm_list */

